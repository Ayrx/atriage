import collections

import re

import subprocess

import click

import itertools

import sys

from atriage import utils


EXPLOITABLE_REGEX = re.compile(
    "<EXPLOITABLE>\n(.*)</EXPLOITABLE>",
    flags=re.DOTALL
)


REG_REGEX = re.compile(
    "<REG>\n(.*)</REG>",
    flags=re.DOTALL
)


def feed_crashes(conn, command, crashes, timeout,
                 exploitable_path, abort_on_error):
    command = command.split()
    input_from_stdin = True
    for index, token in enumerate(command):
        if token == "@@":
            file_index = index
            input_from_stdin = False
            break

    gdb_commands = [
        "gdb",
        "-q",
        "--batch",
        "--ex", "run",
        "--ex", "source {}".format(exploitable_path),
        "--ex", "echo <EXPLOITABLE>\n",
        "--ex", "exploitable -v",
        "--ex", "echo </EXPLOITABLE>\n",
        "--ex", "echo <REG>\n",
        "--ex", "info reg",
        "--ex", "echo </REG>\n",
        "--args",
    ]

    if abort_on_error:
        gdb_env = {"ASAN_OPTIONS": "abort_on_error=1"}
    else:
        gdb_env = {}

    output = {}
    for crash_id, c in crashes:
        if not input_from_stdin:
            command[file_index] = str(c)
            inp = None
        else:
            with open(c, 'rb') as f:
                inp = f.read()

        command_string = " ".join(command)
        combined_command = gdb_commands + command

        try:
            proc = utils.run_killchild(combined_command, timeout=timeout,
                                       input=inp,
                                       stderr=subprocess.STDOUT,
                                       stdout=subprocess.PIPE,
                                       env=gdb_env)
            gdb_msg = proc.stdout.decode("utf-8", "backslashreplace")

            exploitable_output = EXPLOITABLE_REGEX.search(gdb_msg).group(1)
            exploitable_output = parse_exploitable(exploitable_output)

            register_output = REG_REGEX.search(gdb_msg).group(1)

            if exploitable_output:
                save_crashes(
                    conn, crash_id, exploitable_output, register_output)

        except subprocess.TimeoutExpired:
            out_msg = "---CRASH SUMMARY---\n"
            out_msg += "Filename: {}\n".format(str(c))
            out_msg += "Command: {}\n".format(command_string)
            out_msg += "Crash case timed out.\n"
            out_msg += "---END SUMMARY---"

            click.echo(out_msg)
            continue

        if exploitable_output:
            out_msg = "---CRASH SUMMARY---\n"
            out_msg += "Filename: {}\n".format(str(c))
            out_msg += "Command: {}\n".format(command_string)

            out_msg += "Classification: {}\n".format(
                exploitable_output.exploitability)
            out_msg += "Hash: {}\n".format(exploitable_output.hash_value)
            out_msg += "Faulting Frame:\n"
            out_msg += "   {}\n".format(exploitable_output.faulting_frame)
            out_msg += "Disassembly:\n"
            for i in exploitable_output.disassembly.split("\n"):
                out_msg += "   {}\n".format(i)
            out_msg += "Stack trace:\n"
            for i in exploitable_output.stack_trace.split("\n"):
                out_msg += "   {}\n".format(i)

            out_msg += "Registers:\n"
            out_msg += "{}\n".format(register_output)

            out_msg += "Extra Data:\n"
            out_msg += "   Description: {}\n".format(
                exploitable_output.description)
            out_msg += "   Short description: {}\n".format(
                exploitable_output.short_description)
            out_msg += "   Explanation: {}\n".format(
                exploitable_output.explanation)

            out_msg += "---END SUMMARY---"

            click.echo(out_msg)

            output.setdefault(
                exploitable_output.hash_value, []
            ).append((exploitable_output, register_output))

    ret = []
    for hash_value, crashes in output.items():
        out_msg = ""
        num_crashes = len(crashes)
        crash, register_output = crashes[0]

        out_msg = "---CRASH SUMMARY---\n"
        out_msg += "Filename: {}\n".format(str(c))
        out_msg += "Command: {}\n".format(command_string)

        out_msg += "Classification: {}\n".format(
            crash.exploitability)
        out_msg += "Hash: {}\n".format(crash.hash_value)
        out_msg += "Number of matching crashes: {}\n".format(num_crashes)
        out_msg += "Faulting Frame:\n"
        out_msg += "   {}\n".format(crash.faulting_frame)
        out_msg += "Disassembly:\n"
        for i in crash.disassembly.split("\n"):
            out_msg += "   {}\n".format(i)
        out_msg += "Stack trace:\n"
        for i in crash.stack_trace.split("\n"):
            out_msg += "   {}\n".format(i)

        out_msg += "Registers:\n"
        out_msg += "{}\n".format(register_output)

        out_msg += "Extra Data:\n"
        out_msg += "   Description: {}\n".format(
            crash.description)
        out_msg += "   Short description: {}\n".format(
            crash.short_description)
        out_msg += "   Explanation: {}\n".format(
            crash.explanation)

        out_msg += "---END SUMMARY---"

        ret.append(out_msg)

    return ret


ExploitableOutput = collections.namedtuple("ExploitableOutput", [
    "signal_info",
    "disassembly",
    "stack_trace",
    "faulting_frame",
    "description",
    "short_description",
    "hash_value",
    "exploitability",
    "explanation",
])


def parse_exploitable(instring):
    signal_info = ""
    disassembly = ""
    stack_trace = ""
    faulting_frame = ""
    description = ""
    short_description = ""
    hash_value = ""
    exploitability = ""
    explanation = ""

    line = iter(instring.split("\n"))

    try:
        while True:
            curr_line = next(line)
            if curr_line.startswith("Signal si_signo"):
                signal_info = curr_line
                break

        while True:
            curr_line = next(line)
            if curr_line.startswith("Nearby code"):
                break

        while True:
            curr_line = next(line)
            if curr_line.startswith("Stack trace"):
                break

            disassembly += curr_line
            disassembly += "\n"

        while True:
            curr_line = next(line)
            if curr_line.startswith("Faulting frame"):
                faulting_frame = curr_line.split(":")[1].lstrip().rstrip()
                break

            stack_trace += curr_line
            stack_trace += "\n"

        while True:
            curr_line = next(line)
            if curr_line.startswith("Description"):
                description = curr_line.split(":")[1].lstrip().rstrip()
                break

        while True:
            curr_line = next(line)
            if curr_line.startswith("Short description"):
                short_description = curr_line.split(":")[1].lstrip().rstrip()
                break

        while True:
            curr_line = next(line)
            if curr_line.startswith("Hash"):
                hash_value = curr_line.split(":")[1].lstrip().rstrip()
                break

        while True:
            curr_line = next(line)
            if curr_line.startswith("Exploitability Classification"):
                exploitability = curr_line.split(":")[1].lstrip().rstrip()
                break

        while True:
            curr_line = next(line)
            if curr_line.startswith("Explanation"):
                explanation = curr_line.split(":")[1].lstrip().rstrip()
                break

        return ExploitableOutput(
            signal_info,
            disassembly,
            stack_trace,
            faulting_frame,
            description,
            short_description,
            hash_value,
            exploitability,
            explanation
        )
    except StopIteration:
        return None


def save_crashes(conn, crash_id, exploitable_output, register_output):
    p = tuple(itertools.chain(
        (int(crash_id), ),
        exploitable_output,
        (register_output, )
    ))
    conn.execute("""INSERT OR IGNORE INTO exploitable (
                      crash_id,
                      signal_info,
                      disassembly,
                      stack_trace,
                      faulting_frame,
                      description,
                      short_description,
                      hash_value,
                      exploitability,
                      explanation,
                      register_info
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ? ,? ,?)""", p)
    conn.commit()
